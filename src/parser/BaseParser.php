<?php
/* This file has been generated by the Parsian parser generator 
 * (see http://github.com/thomasbollmeier/parsian)
 * 
 * DO NOT EDIT THIS FILE!
 */
namespace tbollmeier\ape\parser;

use tbollmeier\parsian as parsian;
use tbollmeier\parsian\output\Ast;


class BaseParser extends parsian\Parser
{
    public function __construct()
    {
        parent::__construct();

        $this->configLexer();
        $this->configGrammar();
    }

    private function configLexer()
    {

        $lexer = $this->getLexer();

        $lexer->addCommentType("//", "\n");

        $lexer->addStringType("\"", "#\"");

        $lexer->addSymbol("==", "EQ2");
        $lexer->addSymbol("!=", "NE");
        $lexer->addSymbol(">", "GT");
        $lexer->addSymbol("<", "LT");
        $lexer->addSymbol("!", "NOT");
        $lexer->addSymbol("=", "EQ");
        $lexer->addSymbol("||", "OR");
        $lexer->addSymbol("&&", "AND");
        $lexer->addSymbol(";", "SEMICOLON");
        $lexer->addSymbol("+", "PLUS");
        $lexer->addSymbol("-", "MINUS");
        $lexer->addSymbol("*", "ASTERISK");
        $lexer->addSymbol("/", "SLASH");
        $lexer->addSymbol("(", "LPAR");
        $lexer->addSymbol(")", "RPAR");
        $lexer->addSymbol("[", "LBRACKET");
        $lexer->addSymbol("]", "RBRACKET");
        $lexer->addSymbol("{", "LBRACE");
        $lexer->addSymbol("}", "RBRACE");
        $lexer->addSymbol(",", "COMMA");
        $lexer->addSymbol(":", "COLON");

        $lexer->addTerminal("/[a-zA-Z_][a-zA-Z0-9_]*/", "ID");
        $lexer->addTerminal("/(0|[1-9][0-9]*)/", "INT");

        $lexer->addKeyword("let");
        $lexer->addKeyword("return");
        $lexer->addKeyword("null");
        $lexer->addKeyword("true");
        $lexer->addKeyword("false");
        $lexer->addKeyword("fn");
        $lexer->addKeyword("if");
        $lexer->addKeyword("else");

    }

    private function configGrammar()
    {

        $grammar = $this->getGrammar();

        $grammar->rule("ape",
            $grammar->ruleRef("block"),
            true);
        $grammar->rule("block",
            $grammar->opt($this->block()),
            false);

        $grammar->setCustomRuleAst("block", function (Ast $ast) {
            $res = new Ast("block", "");
            foreach ($ast->getChildrenById("st") as $local_1) {
                $local_1->clearId();
                $res->addChild($local_1);
            }
            return $res;
        });

        $grammar->rule("stmt",
            $this->stmt(),
            false);

        $grammar->setCustomRuleAst("stmt", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("let_stmt",
            $this->let_stmt(),
            false);

        $grammar->setCustomRuleAst("let_stmt", function (Ast $ast) {
            $res = new Ast("let_stmt", "");
            $local_1 = new Ast("name", $ast->getChildrenById("name")[0]->getText());
            $res->addChild($local_1);
            $local_2 = new Ast("value", "");
            $local_3 = $ast->getChildrenById("value")[0];
            $local_3->clearId();
            $local_2->addChild($local_3);
            $res->addChild($local_2);
            return $res;
        });

        $grammar->rule("return_stmt",
            $this->return_stmt(),
            false);

        $grammar->setCustomRuleAst("return_stmt", function (Ast $ast) {
            $res = new Ast("return_stmt", "");
            $local_1 = new Ast("value", "");
            $local_2 = $ast->getChildrenById("value")[0];
            $local_2->clearId();
            $local_1->addChild($local_2);
            $res->addChild($local_1);
            return $res;
        });

        $grammar->rule("expr",
            $grammar->ruleRef("disjunction"),
            false);

        $grammar->setCustomRuleAst("expr", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("disjunction",
            $this->disjunction(),
            false);
        $grammar->rule("conjunction",
            $this->conjunction(),
            false);
        $grammar->rule("logic_rel",
            $this->logic_rel(),
            false);
        $grammar->rule("sum",
            $this->sum(),
            false);
        $grammar->rule("prod",
            $this->prod(),
            false);
        $grammar->rule("factor",
            $this->factor(),
            false);
        $grammar->rule("atom_expr",
            $this->atom_expr(),
            false);

        $grammar->setCustomRuleAst("atom_expr", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("boolean",
            $this->boolean(),
            false);

        $grammar->setCustomRuleAst("boolean", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("func_expr",
            $this->func_expr(),
            false);
        $grammar->rule("if_expr",
            $this->if_expr(),
            false);
        $grammar->rule("array_literal",
            $this->array_literal(),
            false);

        $grammar->setCustomRuleAst("array_literal", function (Ast $ast) {
            $res = new Ast("array", "");
            foreach ($ast->getChildrenById("el") as $local_1) {
                $local_1->clearId();
                $res->addChild($local_1);
            }
            return $res;
        });

        $grammar->rule("map_literal",
            $this->map_literal(),
            false);

        $grammar->setCustomRuleAst("map_literal", function (Ast $ast) {
            $res = new Ast("map", "");
            foreach ($ast->getChildrenByName("entry") as $local_1) {
                $local_1->clearId();
                $res->addChild($local_1);
            }
            return $res;
        });

        $grammar->rule("entry",
            $this->entry(),
            false);

        $grammar->setCustomRuleAst("entry", function (Ast $ast) {
            $res = new Ast("entry", "");
            $local_1 = $ast->getChildrenById("key")[0];
            $local_1->clearId();
            $res->addChild($local_1);
            $local_2 = $ast->getChildrenById("value")[0];
            $local_2->clearId();
            $res->addChild($local_2);
            return $res;
        });

        $grammar->rule("idx_access_or_call",
            $this->idx_access_or_call(),
            false);
        $grammar->rule("target",
            $this->target(),
            false);

        $grammar->setCustomRuleAst("target", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("group",
            $this->group(),
            false);

        $grammar->setCustomRuleAst("group", function (Ast $ast) {
            $child = $ast->getChildrenById("ex")[0];
            $child->clearId();
            return $child;
        });


    }

    private function alt_1()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("EQ2"))
            ->add($grammar->term("NE"))
            ->add($grammar->term("GT"))
            ->add($grammar->term("LT"));
    }

    private function alt_2()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("PLUS"))
            ->add($grammar->term("MINUS"));
    }

    private function alt_3()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("ASTERISK"))
            ->add($grammar->term("SLASH"));
    }

    private function alt_4()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("NOT"))
            ->add($grammar->term("MINUS"));
    }

    private function alt_5()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($this->seq_10())
            ->add($grammar->ruleRef("expr", "consequent"));
    }

    private function alt_6()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($this->seq_12())
            ->add($grammar->ruleRef("expr", "alternative"));
    }

    private function alt_7()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($this->seq_17())
            ->add($this->seq_18());
    }

    private function atom_expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->ruleRef("if_expr"))
            ->add($grammar->ruleRef("idx_access_or_call"))
            ->add($grammar->ruleRef("array_literal"))
            ->add($grammar->ruleRef("map_literal"))
            ->add($grammar->ruleRef("func_expr"))
            ->add($grammar->ruleRef("boolean"))
            ->add($grammar->term("NULL"))
            ->add($grammar->term("ID"))
            ->add($grammar->term("INT"))
            ->add($grammar->term("STRING"))
            ->add($grammar->ruleRef("group"));
    }

    private function boolean()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("TRUE"))
            ->add($grammar->term("FALSE"));
    }

    private function factor()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($this->seq_7())
            ->add($grammar->ruleRef("atom_expr"));
    }

    private function stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->ruleRef("let_stmt"))
            ->add($grammar->ruleRef("return_stmt"))
            ->add($grammar->ruleRef("expr"));
    }

    private function target()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->ruleRef("array_literal"))
            ->add($grammar->ruleRef("map_literal"))
            ->add($grammar->ruleRef("func_expr"))
            ->add($grammar->term("ID"));
    }


    private function array_literal()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACKET"))
            ->add($grammar->opt($this->seq_13()))
            ->add($grammar->term("RBRACKET"));
    }

    private function block()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("stmt", "st"))
            ->add($grammar->many($this->seq_1()))
            ->add($grammar->opt($grammar->term("SEMICOLON")));
    }

    private function conjunction()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("logic_rel", "elem"))
            ->add($grammar->many($this->seq_3()));
    }

    private function disjunction()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("conjunction", "conj"))
            ->add($grammar->many($this->seq_2()));
    }

    private function entry()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("expr", "key"))
            ->add($grammar->term("COLON"))
            ->add($grammar->ruleRef("expr", "value"));
    }

    private function func_expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("FN"))
            ->add($grammar->term("LPAR"))
            ->add($grammar->opt($this->seq_8()))
            ->add($grammar->term("RPAR"))
            ->add($grammar->term("LBRACE"))
            ->add($grammar->ruleRef("block", "body"))
            ->add($grammar->term("RBRACE"));
    }

    private function group()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LPAR"))
            ->add($grammar->ruleRef("expr", "ex"))
            ->add($grammar->term("RPAR"));
    }

    private function idx_access_or_call()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("target", "tgt"))
            ->add($grammar->oneOrMore($this->alt_7()));
    }

    private function if_expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("IF"))
            ->add($grammar->term("LPAR"))
            ->add($grammar->ruleRef("expr", "condition"))
            ->add($grammar->term("RPAR"))
            ->add($this->alt_5())
            ->add($grammar->opt($this->seq_11()));
    }

    private function let_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LET"))
            ->add($grammar->term("ID", "name"))
            ->add($grammar->term("EQ"))
            ->add($grammar->ruleRef("expr", "value"));
    }

    private function logic_rel()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("sum"))
            ->add($grammar->opt($this->seq_4()));
    }

    private function map_literal()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACE"))
            ->add($grammar->opt($this->seq_15()))
            ->add($grammar->term("RBRACE"));
    }

    private function prod()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("factor"))
            ->add($grammar->many($this->seq_6()));
    }

    private function return_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("RETURN"))
            ->add($grammar->ruleRef("expr", "value"));
    }

    private function seq_1()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("SEMICOLON"))
            ->add($grammar->ruleRef("stmt", "st"));
    }

    private function seq_10()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACE"))
            ->add($grammar->ruleRef("block", "consequent"))
            ->add($grammar->term("RBRACE"));
    }

    private function seq_11()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("ELSE"))
            ->add($this->alt_6());
    }

    private function seq_12()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACE"))
            ->add($grammar->ruleRef("block", "alternative"))
            ->add($grammar->term("RBRACE"));
    }

    private function seq_13()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("expr", "el"))
            ->add($grammar->many($this->seq_14()));
    }

    private function seq_14()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("COMMA"))
            ->add($grammar->ruleRef("expr", "el"));
    }

    private function seq_15()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("entry"))
            ->add($grammar->many($this->seq_16()));
    }

    private function seq_16()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("COMMA"))
            ->add($grammar->ruleRef("entry"));
    }

    private function seq_17()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACKET"))
            ->add($grammar->ruleRef("expr", "idx"))
            ->add($grammar->term("RBRACKET"));
    }

    private function seq_18()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LPAR"))
            ->add($grammar->opt($this->seq_19()))
            ->add($grammar->term("RPAR"));
    }

    private function seq_19()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("expr", "arg"))
            ->add($grammar->many($this->seq_20()));
    }

    private function seq_2()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("OR"))
            ->add($grammar->ruleRef("conjunction", "conj"));
    }

    private function seq_20()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("COMMA"))
            ->add($grammar->ruleRef("expr", "arg"));
    }

    private function seq_3()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("AND"))
            ->add($grammar->ruleRef("logic_rel", "elem"));
    }

    private function seq_4()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_1())
            ->add($grammar->ruleRef("sum"));
    }

    private function seq_5()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_2())
            ->add($grammar->ruleRef("prod"));
    }

    private function seq_6()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_3())
            ->add($grammar->ruleRef("factor"));
    }

    private function seq_7()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_4())
            ->add($grammar->ruleRef("factor"));
    }

    private function seq_8()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("expr", "p"))
            ->add($grammar->many($this->seq_9()));
    }

    private function seq_9()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("COMMA"))
            ->add($grammar->ruleRef("expr", "p"));
    }

    private function sum()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("prod"))
            ->add($grammar->many($this->seq_5()));
    }


}
