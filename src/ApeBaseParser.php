<?php
/* This file has been generated by the Parsian parser generator 
 * (see http://github.com/thomasbollmeier/parsian)
 * 
 * DO NOT EDIT THIS FILE!
 */
namespace tbollmeier\ape;

use tbollmeier\parsian as parsian;
use tbollmeier\parsian\output\Ast;


class ApeBaseParser extends parsian\Parser
{
    public function __construct()
    {
        parent::__construct();

        $this->configLexer();
        $this->configGrammar();
    }

    private function configLexer()
    {

        $lexer = $this->getLexer();


        $lexer->addStringType("\"", "\\");

        $lexer->addSymbol("=", "EQ");
        $lexer->addSymbol(";", "SEMICOLON");
        $lexer->addSymbol("+", "PLUS");
        $lexer->addSymbol("-", "MINUS");
        $lexer->addSymbol("*", "ASTERISK");
        $lexer->addSymbol("/", "SLASH");
        $lexer->addSymbol("(", "LPAR");
        $lexer->addSymbol(")", "RPAR");
        $lexer->addSymbol("[", "LBRACKET");
        $lexer->addSymbol("]", "RBRACKET");

        $lexer->addTerminal("/[a-zA-Z_][a-zA-Z0-9_]*/", "ID");
        $lexer->addTerminal("/[1-9][0-9]*/", "INT");

        $lexer->addKeyword("let");
        $lexer->addKeyword("return");

    }

    private function configGrammar()
    {

        $grammar = $this->getGrammar();

        $grammar->rule("ape",
            $grammar->oneOrMore($grammar->ruleRef("stmt")),
            true);
        $grammar->rule("stmt",
            $this->stmt(),
            false);

        $grammar->setCustomRuleAst("stmt", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("let_stmt",
            $this->let_stmt(),
            false);

        $grammar->setCustomRuleAst("let_stmt", function (Ast $ast) {
            $res = new Ast("let_stmt", "");
            $local_1 = new Ast("name", $ast->getChildrenById("name")[0]->getText());
            $res->addChild($local_1);
            $local_2 = new Ast("value", "");
            $local_3 = $ast->getChildrenById("value")[0];
            $local_3->clearId();
            $local_2->addChild($local_3);
            $res->addChild($local_2);
            return $res;
        });

        $grammar->rule("return_stmt",
            $this->return_stmt(),
            false);

        $grammar->setCustomRuleAst("return_stmt", function (Ast $ast) {
            $res = new Ast("return_stmt", "");
            $local_1 = new Ast("value", "");
            $local_2 = $ast->getChildrenById("value")[0];
            $local_2->clearId();
            $local_1->addChild($local_2);
            $res->addChild($local_1);
            return $res;
        });

        $grammar->rule("expr",
            $this->expr(),
            false);
        $grammar->rule("prod",
            $this->prod(),
            false);
        $grammar->rule("factor",
            $this->factor(),
            false);
        $grammar->rule("atom_expr",
            $this->atom_expr(),
            false);

        $grammar->setCustomRuleAst("atom_expr", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("group",
            $this->group(),
            false);

        $grammar->setCustomRuleAst("group", function (Ast $ast) {
            $child = $ast->getChildrenById("ex")[0];
            $child->clearId();
            return $child;
        });


    }

    private function alt_1()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("PLUS"))
            ->add($grammar->term("MINUS"));
    }

    private function alt_2()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("ASTERISK"))
            ->add($grammar->term("SLASH"));
    }

    private function atom_expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("INT"))
            ->add($grammar->term("ID"))
            ->add($grammar->ruleRef("group"));
    }

    private function stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->ruleRef("let_stmt"))
            ->add($grammar->ruleRef("return_stmt"));
    }


    private function expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("prod"))
            ->add($grammar->many($this->seq_1()));
    }

    private function factor()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("atom_expr", "base"))
            ->add($grammar->many($this->seq_3()));
    }

    private function group()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LPAR"))
            ->add($grammar->ruleRef("expr", "ex"))
            ->add($grammar->term("RPAR"));
    }

    private function let_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LET"))
            ->add($grammar->term("ID", "name"))
            ->add($grammar->term("EQ"))
            ->add($grammar->ruleRef("expr", "value"))
            ->add($grammar->term("SEMICOLON"));
    }

    private function prod()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->ruleRef("factor"))
            ->add($grammar->many($this->seq_2()));
    }

    private function return_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("RETURN"))
            ->add($grammar->ruleRef("expr", "value"))
            ->add($grammar->term("SEMICOLON"));
    }

    private function seq_1()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_1())
            ->add($grammar->ruleRef("prod"));
    }

    private function seq_2()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($this->alt_2())
            ->add($grammar->ruleRef("factor"));
    }

    private function seq_3()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LBRACKET"))
            ->add($grammar->ruleRef("expr", "idx"))
            ->add($grammar->term("RBRACKET"));
    }


}
