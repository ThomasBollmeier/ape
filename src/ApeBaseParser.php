<?php
/* This file has been generated by the Parsian parser generator 
 * (see http://github.com/thomasbollmeier/parsian)
 * 
 * DO NOT EDIT THIS FILE!
 */
namespace tbollmeier\ape;

use tbollmeier\parsian as parsian;
use tbollmeier\parsian\output\Ast;


class ApeBaseParser extends parsian\Parser
{
    public function __construct()
    {
        parent::__construct();

        $this->configLexer();
        $this->configGrammar();
    }

    private function configLexer()
    {

        $lexer = $this->getLexer();


        $lexer->addStringType("\"", "\\");

        $lexer->addSymbol("=", "EQ");
        $lexer->addSymbol(";", "SEMICOLON");

        $lexer->addTerminal("/[a-zA-Z_][a-zA-Z0-9_]*/", "ID");
        $lexer->addTerminal("/[1-9][0-9]*/", "INT");

        $lexer->addKeyword("let");
        $lexer->addKeyword("return");

    }

    private function configGrammar()
    {

        $grammar = $this->getGrammar();

        $grammar->rule("ape",
            $grammar->oneOrMore($grammar->ruleRef("stmt")),
            true);
        $grammar->rule("stmt",
            $this->stmt(),
            false);

        $grammar->setCustomRuleAst("stmt", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });

        $grammar->rule("let_stmt",
            $this->let_stmt(),
            false);

        $grammar->setCustomRuleAst("let_stmt", function (Ast $ast) {
            $res = new Ast("let_stmt", "");
            $local_1 = new Ast("name", $ast->getChildrenById("name")[0]->getText());
            $res->addChild($local_1);
            $local_2 = new Ast("value", "");
            $local_3 = $ast->getChildrenById("value")[0];
            $local_3->clearId();
            $local_2->addChild($local_3);
            $res->addChild($local_2);
            return $res;
        });

        $grammar->rule("return_stmt",
            $this->return_stmt(),
            false);

        $grammar->setCustomRuleAst("return_stmt", function (Ast $ast) {
            $res = new Ast("return_stmt", "");
            $local_1 = new Ast("value", "");
            $local_2 = $ast->getChildrenById("value")[0];
            $local_2->clearId();
            $local_1->addChild($local_2);
            $res->addChild($local_1);
            return $res;
        });

        $grammar->rule("expr",
            $this->expr(),
            false);

        $grammar->setCustomRuleAst("expr", function (Ast $ast) {
            $child = $ast->getChildren()[0];
            $child->clearId();
            return $child;
        });


    }

    private function expr()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->term("INT"))
            ->add($grammar->term("ID"));
    }

    private function stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->alt()
            ->add($grammar->ruleRef("let_stmt"))
            ->add($grammar->ruleRef("return_stmt"));
    }


    private function let_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("LET"))
            ->add($grammar->term("ID", "name"))
            ->add($grammar->term("EQ"))
            ->add($grammar->ruleRef("expr", "value"))
            ->add($grammar->term("SEMICOLON"));
    }

    private function return_stmt()
    {
        $grammar = $this->getGrammar();

        return $grammar->seq()
            ->add($grammar->term("RETURN"))
            ->add($grammar->ruleRef("expr", "value"))
            ->add($grammar->term("SEMICOLON"));
    }


}
