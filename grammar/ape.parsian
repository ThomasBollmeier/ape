(*
Grammar of APE

APE is a PHP implementation of the Monkey programming language
invented by Thorsten Ball (see https://interpreterbook.com/ for details)

Version: 0.5
Author: Thomas Bollmeier <developer@thomas-bollmeier.de>
*)

-- Lexical elements

comment '//' '\n';

literal '"' '#"';

symbol EQ2 '==';
symbol NE '!=';
symbol GT '>';
symbol LT '<';
symbol NOT '!';
symbol EQ '=';
symbol OR '||';
symbol AND '&&';
symbol SEMICOLON ';';
symbol PLUS '+';
symbol MINUS '-';
symbol ASTERISK '*';
symbol SLASH '/';
symbol LPAR '(';
symbol RPAR ')';
symbol LBRACKET '[';
symbol RBRACKET ']';
symbol LBRACE '{';
symbol RBRACE '}';
symbol COMMA ',';
symbol COLON ':';

token ID /[a-zA-Z_][a-zA-Z0-9_]*/;
token INT /[1-9][0-9]*/;

@root
ape -> stmt+;

stmt -> let_stmt
    | return_stmt
    | expr_stmt => child;

let_stmt -> 'let' name#ID EQ value#expr SEMICOLON
=> {
    :name "let_stmt"
    :children [
        {:name "name" :text #name.text}
        {:name "value" :children [#value]}
    ]
};

return_stmt -> 'return' value#expr SEMICOLON
=> {
    :name "return_stmt"
    :children [{:name "value" :children [#value]}]
};

expr_stmt -> ex#expr SEMICOLON
=> {
    :name "expr_stmt"
    :children [#ex]
};

expr -> prod ((PLUS|MINUS) prod)*;

prod -> disjunction ((ASTERISK|SLASH) disjunction)*;

disjunction -> conj#conjunction (OR conj#conjunction)*;

conjunction -> elem#logic_rel (AND elem#logic_rel)*;

logic_rel -> operand ((EQ2 | NE | GT | LT) operand)?;

operand -> (NOT|MINUS) operand | atom_expr;

atom_expr ->
    if_expr |
    idx_access_or_call |
    array_literal |
    map_literal |
    func_expr |
    boolean |
    'null' |
    ID |
    INT |
    STRING |
    group => child;

boolean -> 'true' | 'false' => child;

func_expr -> 'fn' LPAR (p#expr (COMMA p#expr)*)? RPAR
    LBRACE
    st#stmt*
    RBRACE
=> {
    :name "func_expr"
    :children [
        {
            :name "parameters"
            :children #p
        }
        {
            :name "body"
            :children #st
        }
    ]
};

if_expr -> 'if' LPAR condition#expr RPAR
    (LBRACE consequent#stmt+ RBRACE | consequent#expr)
    ('else' (LBRACE alternative#stmt+ RBRACE | alternative#expr))?
=> {
    :name "if"
    :children [
        {:name "condition" :children #condition}
        {:name "consequent" :children #consequent}
        {:name "alternative" :children #alternative}
    ]
};

array_literal -> LBRACKET (el#expr (COMMA el#expr)*)? RBRACKET
=> {
    :name "array"
    :children #el
};

map_literal -> LBRACE (entry (COMMA entry)*)? RBRACE
=> {
    :name "map"
    :children .entry
};

entry -> key#expr COLON value#expr
=> {
    :name "entry"
    :children [#key #value]
};

idx_access_or_call -> tgt#target
    (LBRACKET idx#expr RBRACKET | LPAR (arg#expr (COMMA arg#expr)*)? RPAR)+;

target ->
    array_literal |
    map_literal |
    func_expr |
    ID => child;

group -> LPAR ex#expr RPAR => #ex;
